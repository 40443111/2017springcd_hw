<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>2017springcd電腦輔助設計實習 協同產品設計實習(虎尾科大MDE)</title><link href="./" rel="alternate"></link><link href="./feeds/all.atom.xml" rel="self"></link><id>./</id><updated>2017-06-15T12:08:00+08:00</updated><entry><title>w17期末協統查驗與自評</title><link href="./w17qi-mo-xie-tong-cha-yan-yu-zi-ping.html" rel="alternate"></link><published>2017-06-15T12:08:00+08:00</published><updated>2017-06-15T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-06-15:./w17qi-mo-xie-tong-cha-yan-yu-zi-ping.html</id><summary type="html">&lt;p&gt;期末協統查驗與自評&lt;/p&gt;


&lt;h1&gt;slovespace檔案推送&lt;/h1&gt;
&lt;p&gt;&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/G3Fhb6Ydpao?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;iframe src="./../w17/40443111.html" width="560" height="315" &gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h1&gt;solvespace 2D 繪圖 程式碼&lt;/h1&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/-yN4EQMGd9k?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;p&gt;&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;
&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear2" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

# 設定畫線參數 
    def create_line(self, x1, y1, x2, y2, width=3, fill="#54fff6"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    def create_line2(self, x1, y1, x2, y2, width=3, fill="#54ff5f"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    def create_line3(self, x1, y1, x2, y2, width=3, fill="#f354ff"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()


    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):

        rp = 250
        imax = 15
        m=2*rp/n
        a=m
        d=1.25*m
        ra=rp+a


        # self.create_line(起點X, 起點Y, 終點X, 終點Y)
        self.create_line2(400.0092358669, 99.7467537143, 251.9547191519, 442.8435006599)
        self.create_line3(400.0092358669, 99.7467537143, 537.4903413459, 440.1127860465)
        self.create_line2(143.0084564396, 393.7995926042, 314.6469023490, 471.0653927376)
        self.create_line3(143.0084564396, 393.7995926042, 202.3690092639, 492.0551734376)
        self.create_line2(202.3690092639, 492.0551734376, 314.6469023490, 471.0653927376)
        self.create_line3(465.4788879723, 480.3190039124, 593.2602222967, 408.9747395441)
        self.create_line2(465.4788879723, 480.3190039124, 567.9291276424, 502.4572906272)
        self.create_line3(567.9291276424, 502.4572906272, 593.2602222967, 408.9747395441)




        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(-9, 10, +1):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)   
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear2']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
# 齒數
n = 36
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&lt;/script&gt;

&lt;h1&gt;子模組建立與運用&lt;/h1&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/Ed2qvfWHSv0?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;h1&gt;Solvespace 近端零組件繪圖&lt;/h1&gt;
&lt;p&gt;&lt;p&gt;part1&lt;p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/uxsRnkdLURI?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;part2&lt;p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/j09mlov_6Ak?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;iframe src="./../w17/final.html" width="560" height="315" &gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h1&gt;Solvespace 零件轉入 V-rep&lt;/h1&gt;
&lt;p&gt;&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/Hd3oHLJBoXY?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</summary><category term="HW"></category></entry><entry><title>協同協同產品設計實習 第十五周作業</title><link href="./xie-tong-xie-tong-chan-pin-she-ji-shi-xi-di-shi-wu-zhou-zuo-ye.html" rel="alternate"></link><published>2017-06-01T12:08:00+08:00</published><updated>2017-06-01T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-06-01:./xie-tong-xie-tong-chan-pin-she-ji-shi-xi-di-shi-wu-zhou-zuo-ye.html</id><summary type="html">&lt;p&gt;1.半齒形的漸開線正齒輪輪廓&lt;/p&gt;
&lt;p&gt;2.繪製一齒正齒輪&lt;/p&gt;
&lt;p&gt;3.協同2D正齒輪嚙合&lt;/p&gt;
&lt;p&gt;4.利用Onshape協同繪製正齒輪嚙合&lt;/p&gt;


&lt;h1&gt;1.半徑為 250 , 壓力角 20, 齒數為 36 齒, 半齒形的漸開線正齒輪輪廓&lt;/h1&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
# 齒數
n = 36
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")

ctx.beginPath()
ctx.lineWidth = "600"
ctx.strokeStyle = "white"
ctx.moveTo(0,600)
ctx.lineTo(800,600)
ctx.stroke()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40443111 ",360,320)
ctx.stroke()
&lt;/script&gt;

&lt;p&gt;#2.繪製一齒正齒輪&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear1" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear1_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear1']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2+2400
r = 8*(canvas.height/2)
# 齒數
n = 20
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40443111 ",360,600)
ctx.stroke()
&lt;/script&gt;

&lt;h1&gt;3.協同2D正齒輪嚙合&lt;/h1&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id='gear3' width='1200' height='800'&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)

                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear3" 的 canvas 中繪圖
canvas = doc["gear3"]
ctx = canvas.getContext("2d")

# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# 第1齒輪齒數
n_g1 = 16
# 第2齒輪齒數
n_g2 = 18
# 第3齒輪齒數
n_g3 = 20
# 第4齒輪齒數
n_g4 = 22
# 第5齒輪齒數
n_g5 = 24
# 第6齒輪齒數
n_g6 = 26
# 第7齒輪齒數
n_g7 = 28
# 第8齒輪齒數
n_g8 = 30
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
m = (0.6*canvas.width)/(n_g1+n_g2+n_g3+n_g4)
# 根據模數 m, 計算各齒輪的節圓半徑
rp_g1 = m*n_g1/2
rp_g2 = m*n_g2/2
rp_g3 = m*n_g3/2
rp_g4 = m*n_g4/2
rp_g5 = m*n_g5/2
rp_g6 = m*n_g6/2
rp_g7 = m*n_g7/2
rp_g8 = m*n_g8/2
#單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, "blue")
# 開始繪製囓合齒輪輪廓
# 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離
x_g1 = canvas.width*0.05+rp_g1
# y 方向繪圖區域上方預留 canvas.height 的 20%
y_g1 = canvas.height*0.1+rp_g1
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x_g2 = x_g1 + rp_g1 + rp_g2
y_g2 = y_g1
# 第3齒輪的圓心座標
x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
y_g3 = y_g1

# 第4齒輪的圓心座標
x_g4 = x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4
y_g4 = y_g1

# 第5齒輪的圓心座標
x_g5 = x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4
y_g5 = y_g4+rp_g4+rp_g5

# 第6齒輪的圓心座標
x_g6 =x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4
y_g6 = y_g5+rp_g5+rp_g6

# 第7齒輪的圓心座標
x_g7 =x_g6-rp_g6-rp_g7
y_g7 = y_g5+rp_g5+rp_g6

# 第8齒輪的圓心座標
x_g8 =x_g7-rp_g7-rp_g8
y_g8 = y_g5+rp_g5+rp_g6

# 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g1, y_g1)
# rotate to engage
ctx.rotate(math.pi/2)
# put it back
ctx.translate(-x_g1, -y_g1)
# 繪製第一個齒輪輪廓
Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "purple")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423105 ",x_g1-20, y_g1)
ctx.stroke()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g2, y_g2)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n_g2)
# put it back
ctx.translate(-x_g2, -y_g2)
Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "red")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423119 ",x_g2-20, y_g2)
ctx.stroke()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g3, y_g3)
# rotate to engage
# math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3)
# put it back
ctx.translate(-x_g3, -y_g3)
Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "black")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423128 ",x_g3-20, y_g3)
ctx.stroke()

# 將第4齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g4, y_g4)
# rotate to engage
ctx.rotate(math.pi/2-math.pi/n_g4+(math.pi+math.pi/n_g3)*n_g3/n_g4*2)
# put it back
ctx.translate(-x_g4, -y_g4)
Spur(ctx).Gear(x_g4, y_g4, rp_g4, n_g4, pa, "green")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423130 ",x_g4-20, y_g4)
ctx.stroke()


# 將第5齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g5, y_g5)
# rotate to engage
ctx.rotate(math.pi/2-math.pi/n_g5+(math.pi+math.pi/n_g4)*n_g4/n_g5*2)
# put it back
ctx.translate(-x_g5, -y_g5)
Spur(ctx).Gear(x_g5, y_g5, rp_g5, n_g5, pa, "red")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423133 ",x_g5-20, y_g5)
ctx.stroke()


# 將第6齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g6, y_g6)
# rotate to engage
ctx.rotate(math.pi/2-math.pi/n_g6+(math.pi+math.pi/n_g5)*n_g5/n_g6*2)
# put it back
ctx.translate(-x_g6, -y_g6)
Spur(ctx).Gear(x_g6, y_g6, rp_g6, n_g6, pa, "black")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423137 ",x_g6-20, y_g6)
ctx.stroke()


# 將第7齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g7, y_g7)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n_g7+(math.pi+math.pi/n_g6)*n_g6/n_g7)
# put it back
ctx.translate(-x_g7, -y_g7)
Spur(ctx).Gear(x_g7, y_g7, rp_g7, n_g7, pa, "purple")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423144 ",x_g7-20, y_g7)
ctx.stroke()

# 將第8齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g8, y_g8)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n_g8+(math.pi+math.pi/n_g7)*n_g7/n_g8*2)
# put it back
ctx.translate(-x_g8, -y_g8)
Spur(ctx).Gear(x_g8, y_g8, rp_g8, n_g8, pa, "purple")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40443111 ",x_g8-20, y_g8)
ctx.stroke()
&lt;/script&gt;

&lt;h1&gt;4.利用Onshape協同繪製正齒輪嚙合&lt;/h1&gt;
&lt;iframe src="https://player.vimeo.com/video/219786602" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/219786602"&gt;國立虎尾科技大學_協同產品設計實習_設計二甲_40423137_陳慶豪_W15_Onshape 齒輪組的囓合協同繪圖&lt;/a&gt; from &lt;a href="https://vimeo.com/user45109608"&gt;40423137&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;</summary><category term="HW"></category></entry><entry><title>協同協同產品設計實習 第十二周作業</title><link href="./xie-tong-xie-tong-chan-pin-she-ji-shi-xi-di-shi-er-zhou-zuo-ye.html" rel="alternate"></link><published>2017-05-11T12:08:00+08:00</published><updated>2017-05-11T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-05-11:./xie-tong-xie-tong-chan-pin-she-ji-shi-xi-di-shi-er-zhou-zuo-ye.html</id><summary type="html">&lt;p&gt;1.為何需要減速機?&lt;/p&gt;
&lt;p&gt;2.何謂漸開線?&lt;/p&gt;
&lt;p&gt;3.如何畫漸開線正齒輪輪廓?&lt;/p&gt;
&lt;p&gt;4.如何模擬 2D 正齒輪組囓合？&lt;/p&gt;
&lt;p&gt;5.如何模擬 3D 正齒輪組囓合？
&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear" width="600" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=17, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr

                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

canvas = doc['onegear']
ctx = canvas.getContext("2d")
x = (canvas.width)/4
y = (canvas.height)/4
r = 0.8*(canvas.height/4)
# 齒數
n = 17
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&lt;/script&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear1" width="600" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear1_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=17, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr

                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

canvas = doc['onegear1']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
# 齒數
n17 = 17
n11 = 11
n13 = 13
canvas_size = canvas.height*0.4
r17 = canvas_size*n17/(n17+n11+n13)
r11 = canvas_size*n11/(n17+n11+n13)
r13 = canvas_size*n13/(n17+n11+n13)
x17 = x-5 - r17
x11 = x-5 + r11
x13 = x-5+ 2*r11 + r13
y17 = y
y11 = y
y13 = y
# 壓力角
pa = 20
gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa, "blue")
gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa, "red")
gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa, "blue")

div = doc["onegear_div"]

&lt;/script&gt;

&lt;p&gt;網際正齒輪組傳動繪圖&lt;/p&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="onegear2" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear2_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="n1" value="13"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="n2" value="11"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="n3" value="17"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="button"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

canvas = doc['onegear2']
ctx = canvas.getContext("2d")

# 以 button 驅動的事件函式
def setgearnumber(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = (canvas.width)/2
    y = (canvas.height)/2
    if doc["n1"].value.isdigit():
        n17 = int(doc["n1"].value)
    else:
        n17 = 17

    if doc["n2"].value.isdigit():
        n11 = int(doc["n2"].value)
    else:
        n11 = 11

    if doc["n3"].value.isdigit():
        n13 = int(doc["n3"].value)
    else:
        n13 = 13

    # 只使用畫布高度的 80%
    canvas_size = canvas.height*0.4
    r17 = canvas_size*n17/(n17+n11+n13)
    r11 = canvas_size*n11/(n17+n11+n13)
    r13 = canvas_size*n13/(n17+n11+n13)
    # 計算各齒輪中心座標
    x17 = x - r17-r11
    y17 = y

    x11 = x 
    y11 = y

    x13 = x + r11+r13
    y13 = y

    pa = 20
    # 開始繪製齒輪
    # 儲存原有的座標系統
    ctx.save()
    # 平移到齒輪圓心
    ctx.translate(x17, y17)
    # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平
    ctx.rotate(90*deg)
    # 平移回原來的座標原點
    ctx.translate(-x17, -y17)
    gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa, "blue")
    # 回復原有的座標系統
    ctx.restore()

    ctx.save()
    ctx.translate(x11, y11)
    # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n11)
    ctx.translate(-x11, -y11)
    gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa, "blue")
    ctx.restore()

    ctx.save()
    ctx.translate(x13, y13)
    # 右側齒輪轉動 -90 度加上一齒, 可以與原來標線在左側水平的中間齒輪囓合, 但是目前中間齒輪的標線已經轉了 180 度加或減一次
    # 必須配合兩齒的速比轉換旋轉角, 以便讓中間齒輪與右側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n13+(180*deg+math.pi/n11)*n11/n13)
    ctx.translate(-x13, -y13)
    gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa, "blue")
    ctx.restore()

setgearnumber(True)

'''
div = doc["onegear2_div"]
form = html.FORM()
input1 = html.INPUT(type="text", id="n1", name="n1", value="13")
input2 = html.INPUT(type="text", id="n2", name="n2", value="11")
input3 = html.INPUT(type="text", id="n3", name="n3", value="19")
div &lt;= input1 + html.BR() + input2 + html.BR() + input3
'''
doc['button'].bind('click',setgearnumber)
&lt;/script&gt;

&lt;h2&gt;4.如何模擬 2D 正齒輪組囓合？&lt;/h2&gt;
&lt;!-- 以下處理 Cango Spur Gear --&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../data/cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/cango
/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
#cobj = window.Cobj.new
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new
tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 11
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.4*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = shape(data, {
  "fillColor":"#ddd0dd",
  "border": True,
  "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
 # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = path(shapedefs.circle(hr))
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

# setup the animation
# backlash (mm)
bklsh = 0.04*m
# centre shift to make backlash
dC = bklsh/(3*math.tan(math.pi*pa/180))
# np 為小齒輪齒數
np = 13
# gear ratio
gr = n/np              
gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]}
# gr*0.666 rpm
#pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]}
# 0.666 rpm
twnr = tweener(0, 90000, "loop")

cx = canvas.width/2
cy = canvas.height/2
#gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
#cgo.render(gear)
#cgo.render(gear2)
#cgo.render(gear3)
# 利用 gear 資料複製一份, 命名為 gear
gear1 = gear.dup()
gear2 = gear1.dup()
gear3 = gear1.dup()
from time import time
from browser.timer import request_animation_frame as raf
from browser.timer import set_interval

deg = math.pi/180

def draw():
    cgo.clearCanvas()
    gear.rotate(2*deg)
    # 在特定位置, 以特定 scale, 特定 degs 執行 render
    cgo.render(gear, {'x':cx-pr/2, 'y':cy, 'scl':0.5, 'degs':0})
    gear1.rotate(-2*deg)
    cgo.render(gear1, {'x':cx+pr*2*0.5-pr/2, 'y':cy, 'scl':0.5, 'degs':0})
    gear2.rotate(2*deg)
    cgo.render(gear2, {'x':cx+pr*2*0.5*2-pr/2, 'y':cy, 'scl':0.5, 'degs':0})
    gear3.rotate(-2*deg)
    cgo.render(gear3, {'x':cx+pr*2*0.5*2-pr/2, 'y':1.43*cy, 'scl':0.5, 'degs':147})

set_interval(draw, 2)
&lt;/script&gt;</summary><category term="HW"></category></entry><entry><title>多四連桿行走機構模擬</title><link href="./duo-si-lian-gan-xing-zou-ji-gou-mo-ni.html" rel="alternate"></link><published>2017-05-04T12:08:00+08:00</published><updated>2017-05-04T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-05-04:./duo-si-lian-gan-xing-zou-ji-gou-mo-ni.html</id><summary type="html">&lt;p&gt;多四連桿行走機構模擬&lt;/p&gt;


&lt;h2&gt;多四連桿行走機構模擬影片&lt;/h2&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/5CfIpbY7N-s" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="HW"></category></entry><entry><title>協同協同產品設計實習 第十一周作業之二</title><link href="./xie-tong-xie-tong-chan-pin-she-ji-shi-xi-di-shi-yi-zhou-zuo-ye-zhi-er.html" rel="alternate"></link><published>2017-05-03T12:08:00+08:00</published><updated>2017-05-03T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-05-03:./xie-tong-xie-tong-chan-pin-she-ji-shi-xi-di-shi-yi-zhou-zuo-ye-zhi-er.html</id><summary type="html">&lt;p&gt;1.協同2D正齒輪傳動繪圖(二)&lt;/p&gt;


&lt;p&gt;利用漸開線原理, 以 Brython 繪製單一正齒輪廓:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&lt;/script&gt;

&lt;p&gt;齒數：13t
&lt;!-- 以下處理 Cango Spur Gear --&gt;&lt;/p&gt;
&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
#cobj = window.Cobj.new
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new

tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 13
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = shape(data, {
  "fillColor":"#ddd0dd",
  "border": True,
  "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = path(shapedefs.circle(hr))
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

# setup the animation
# backlash (mm)
bklsh = 0.04*m
# centre shift to make backlash
dC = bklsh/(2*math.tan(math.pi*pa/180))
# np 為小齒輪齒數
np = 13
# gear ratio
gr = n/np              
gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]}
# gr*0.666 rpm
#pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]}
# 0.666 rpm
twnr = tweener(0, 90000, "loop")

cx = canvas.width/2
cy = canvas.height/2
#gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
#cgo.render(gear)
# 利用 gear 資料複製一份, 命名為 gear1
gear1 = gear.dup()

from time import time
from browser.timer import request_animation_frame as raf
from browser.timer import set_interval

deg = math.pi/180

def draw():
    cgo.clearCanvas()
    gear.rotate(2*deg)
    # 在特定位置, 以特定 scale, 特定 degs 執行 render
    cgo.render(gear, {'x':cx-pr/2, 'y':cy, 'scl':0.5, 'degs':0})
    gear1.rotate(-2*deg)
    cgo.render(gear1, {'x':cx+pr*2*0.5-pr/2, 'y':cy, 'scl':0.5, 'degs':0})

set_interval(draw, 2)
&lt;/script&gt;</summary><category term="HW"></category></entry><entry><title>協同產品設計實習 第十一周作業之一</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-di-shi-yi-zhou-zuo-ye-zhi-yi.html" rel="alternate"></link><published>2017-05-02T12:08:00+08:00</published><updated>2017-05-02T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-05-02:./xie-tong-chan-pin-she-ji-shi-xi-di-shi-yi-zhou-zuo-ye-zhi-yi.html</id><summary type="html">&lt;p&gt;1.協同2D正齒輪傳動繪圖&lt;/p&gt;


&lt;p&gt;利用漸開線原理, 以 Brython 繪製單一正齒輪廓:&lt;/p&gt;
&lt;p&gt;齒數：13t
&lt;!-- 導入 Brython 標準程式庫 --&gt;&lt;/p&gt;
&lt;script src="../data/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
# 齒數
n = 13
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&lt;/script&gt;

&lt;p&gt;齒數：11t
&lt;!-- 以下處理 Cango Spur Gear --&gt;&lt;/p&gt;
&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/Cango2D-7v01-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/CangoAnimation-4v01.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = window.Cobj.new
creategeartooth = window.createGearTooth.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 11
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&lt;/script&gt;</summary><category term="HW"></category></entry><entry><title>協同產品設計實習 第十周作業</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-di-shi-zhou-zuo-ye.html" rel="alternate"></link><published>2017-04-27T12:08:00+08:00</published><updated>2017-04-27T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-04-27:./xie-tong-chan-pin-she-ji-shi-xi-di-shi-zhou-zuo-ye.html</id><summary type="html">&lt;p&gt;加法查驗&lt;/p&gt;


&lt;h2&gt;加法查驗&lt;/h2&gt;
&lt;p&gt;加法查驗影片&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/KrVRWU1XzOw?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;程式碼&lt;/p&gt;
&lt;p&gt;mul.py
&lt;pre class="brush: python"&gt;
def mul(a, b): #定義 a , b
    return a+b #a 加 b
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;app2.py
&lt;pre class="brush: python"&gt;
import sys #導入 sys
sys.path.append("./m1") #資料夾路徑
import mul #導入 mul.py&lt;/p&gt;
&lt;p&gt;multiply = mul.mul(5, 5) #乘法演算&lt;/p&gt;
&lt;p&gt;print(multiply) #輸出結果
&lt;/pre&gt;&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;h1&gt;網頁測試乘法&lt;/h1&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;

&lt;!--&lt;canvas id="w10" width="800" height="600"&gt;&lt;/canvas&gt;--&gt;

&lt;div id="container3" width="600" height="400"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
container = doc['container3']
degree = math.pi/180
def button3(event):
    a = input("give me a")
    b = input("give me b")
    container &lt;= str(float(a)+float(b))
doc["button3"].bind("click", button3)

&lt;/script&gt;

&lt;p&gt;&lt;button id="button3"&gt;按下取 a b 值&lt;/button&gt;&lt;/p&gt;</summary><category term="HW"></category></entry><entry><title>協同產品設計實習 期中協同查驗與自評</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-qi-zhong-xie-tong-cha-yan-yu-zi-ping.html" rel="alternate"></link><published>2017-04-20T12:08:00+08:00</published><updated>2017-04-20T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-04-20:./xie-tong-chan-pin-she-ji-shi-xi-qi-zhong-xie-tong-cha-yan-yu-zi-ping.html</id><summary type="html">&lt;p&gt;Fossil Server 實習查驗&lt;p&gt;

&lt;p&gt;四連桿機構協同 Trace Point 查驗&lt;p&gt;

&lt;p&gt;Fourbar Walker OnShape 零件協同繪圖與組立查驗&lt;p&gt;

&lt;p&gt;分組協同零件展示&lt;p&gt;






&lt;p&gt;(一) Fossil Server 實習查驗&lt;p&gt;

&lt;a href="https://mde2a2.kmol.info/midterm/ag1/index"&gt;ag1期中考報告 fossil &lt;/a&gt;

&lt;p&gt;(二) 四連桿機構協同 Trace Point 查驗&lt;p&gt;

&lt;a href="https://40443111.github.io/2016fallcadp_hw/blog/xie-tong-chan-pin-she-ji-shi-xi-qi-zhong-xie-tong-cha-yan-yu-zi-ping.html"&gt;40443111_四連桿機構協同 Trace Point 查驗&lt;/a&gt;

&lt;p&gt;

&lt;p&gt;(三) Fourbar Walker OnShape 零件協同繪圖與組立查驗&lt;p&gt;

&lt;p&gt;利用SolveSpace畫Fourbar Walker影片&lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/V0OtKulxlzY?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;利用SolveSpace畫Fourbar Walker圖片&lt;p&gt;

&lt;a href="http://imgur.com13/IY3RC"&gt;&lt;img src="http://i.imgur.com/IY313RC.png" title="source: imgur.com" /&gt;&lt;/a&gt;

&lt;p&gt;利用OnShape組立Fourbar Walker影片&lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/FPcyZXgrDn0?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;(四) 分組協同零件展示&lt;p&gt;

&lt;link href="./../work/madeleine/src/css/Madeleine.css" rel="stylesheet"&gt;
&lt;script src="./../work/madeleine/src/stats.js"&gt;&lt;/script&gt;
&lt;script src="./../work/madeleine/src/detector.js"&gt;&lt;/script&gt;
&lt;script src="./../work/madeleine/src/three.min.js"&gt;&lt;/script&gt;
&lt;script src="./../work/madeleine/src/Madeleine.js"&gt;&lt;/script&gt;

&lt;div id="target" class="madeleine"&gt;&lt;/div&gt;

&lt;script&gt;
window.onload = function(){
    var madeleine = new Madeleine({
      target: 'target', // target div id
      data: './../data/Fourbar Walker.stl', // data path
      path: './../work/madeleine/src/' // path to source directory from current html file
    });
}; 
&lt;/script&gt;

&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.min.js"
&gt;&lt;/script&gt;
&lt;script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"
&gt;&lt;/script&gt;
&lt;script src="./../w9/loader.js"&gt;&lt;/script&gt;
&lt;script src="./../w9/stl.js"&gt;&lt;/script&gt;
&lt;div&gt;
select stl file: &lt;input type="file" id="file" /&gt; or drop stl file
&lt;/div&gt;
&lt;div id="view"&gt;&lt;/div&gt;</summary><category term="HW"></category></entry><entry><title>協同產品設計實習 第六周作業</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-di-liu-zhou-zuo-ye.html" rel="alternate"></link><published>2017-04-03T12:08:00+08:00</published><updated>2017-04-03T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-04-03:./xie-tong-chan-pin-she-ji-shi-xi-di-liu-zhou-zuo-ye.html</id><summary type="html">&lt;p&gt;四連桿運動模擬&lt;p&gt;

&lt;p&gt;八連桿運動模擬&lt;p&gt;






&lt;p&gt;四連桿零件 &lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/0XuW6fqn_tg?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;四連桿組合 &lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/xqofOG86Xg0?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;四連桿零v-rep&lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/pph68qt9K6I?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;8bars零件 &lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/QmDVc58vzr0?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;8bars零件 &lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/xqofOG86Xg0?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;8bars零件 &lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/_9PB35Xnj3c?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;心得&lt;p&gt;

這次是花了最多時間的一次,也是重畫最多次的一遍,幸好最後還是撐工畫出來了</summary><category term="HW"></category></entry><entry><title>協同產品設計實習 第五周作業</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-di-wu-zhou-zuo-ye.html" rel="alternate"></link><published>2017-03-26T12:08:00+08:00</published><updated>2017-03-26T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-03-26:./xie-tong-chan-pin-she-ji-shi-xi-di-wu-zhou-zuo-ye.html</id><summary type="html">&lt;p&gt;單連桿機構轉入 V-rep 進行運動模擬&lt;p&gt;





&lt;p&gt;單連桿模擬&lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/aeKd2fck0Ns?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;利用v-rep設定單連桿運動&lt;p&gt;


&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/mC2ZDZPBd-8?ecver=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;心得&lt;p&gt;

本來想說怎麼部會動 原來是數值給的不夠</summary><category term="HW"></category></entry><entry><title>協同產品設計實習 第四周作業</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-di-si-zhou-zuo-ye.html" rel="alternate"></link><published>2017-03-19T12:08:00+08:00</published><updated>2017-03-19T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-03-19:./xie-tong-chan-pin-she-ji-shi-xi-di-si-zhou-zuo-ye.html</id><summary type="html">&lt;p&gt;利用Solvespace及Onshape繪製四連桿機構並組立&lt;p&gt;

&lt;p&gt;將四連桿機構組立轉成STL檔，並轉入V-rep&lt;p&gt;
&lt;p&gt;平面四連桿機構的運動路徑方程式推導&lt;p&gt;

&lt;p&gt;四連桿平面機構繪圖&lt;p&gt;



#&lt;p&gt;第四週作業&lt;p&gt;

&lt;p&gt;利用簡報說明安裝 Hyperworks 套件過程, 透過使用 Hyperworks 進行連桿機構零件的應力分析與機構運動模擬.&lt;/p&gt;


&lt;p&gt;零件1&lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/36DwIO738Cc" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;零件2&lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/z4ATr6gLUHc" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;零件3&lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/jCcAs1av3e0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;組裝&lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/ppPs7k-V0IQ" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="HW"></category></entry><entry><title>協同產品設計實習 第三周作業</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-di-san-zhou-zuo-ye.html" rel="alternate"></link><published>2017-03-12T12:08:00+08:00</published><updated>2017-03-12T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-03-12:./xie-tong-chan-pin-she-ji-shi-xi-di-san-zhou-zuo-ye.html</id><summary type="html">&lt;p&gt;Hyperworks翻譯(英翻中)&lt;p&gt;





&lt;p&gt;翻譯影片hyperworks2中文字幕&lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/WGAmkWxPiig" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
##內容
The 2017 HyperWorks release has a lot 在2017年HyperWorks發行很多版本

of enhancements to the modeling and assembly capabilities 對軟件的建模和組裝能力的增強

So we put in a new parts browser with a built-in part library 所以我們在一個新的零件瀏覽器與一個內置零件庫

The part library is a great tool for storing and loading work in progress 零件庫是用於存儲和加載正在進行工作的一個很好的工具

So you can store a catalog of all the common parts 因此，您可以存儲所有公共部分的目錄

that a workgroup needs to use,so they can download their models from their PLM system 工作組需要使用，因此他們可以從他們的PLM系統下載他們的模型

and store them locally in a parts library for a work in progress 並將它們本地存儲在正在進行的工作的零件庫中

And it keeps revision control on them, 他保持對它們的修訂控制

so they can back up to the different versions and reload. 所以他們可以備份到不同的版本並重新加載。

And they can also build different configurations now of their models. 他們也可以建立不同的配置到他們現在的的模型。

In the configuration modeler now 現在在配置建模器

they can import parts from part library and then group 他們可以從零件庫導入零件然後分組

them into what we call part sets,which are 他們變成我們所說的部分集

convenient groupings of parts. 即零件方便分組

And then they can drag those parts together into assemblies, 然後他們可以將這些部分一起拖入組件

and configure them for different load 並為不同負載配置它們的

cases or different variations of their models. 情況或他們的模型的不同變化

the other feature of haveing parts in the software 硬件部分的軟件中的另一個特點

is we do part instancing now,too. 我們現在也做實例化

So if you load in a part that has 所以如果你加載在一個部分

multiple instances through the model,we support that. 我們支持多個實例通過模型

We don't have to create multiple copies of it. 我們不必創建它的多個副本

We can actually do the instancing,which is very memory efficient. 我們可以做實際，這是非常有效的記憶。

Also in the model building assembly 也在模型建築組裝

tool set is enhanced ID management as well. 工具集也是增強的ID管理

So not only can we assign IDs based on different rules 因此，我們不僅可以根據不同的規則分配ID

that you define in the software,but you can import ID systems 您可以在軟件中定義，但可以導入ID系統

form spreadsheets,XML files,databases, 形式電子表格，XML文件，數據庫，

and so forth,that are then used when 等等，然後在使用

it does the renumbering or the assembly of the model. 它進行重新編號或模型的組裝

it has to resolve part collisions. 它必須解決部分碰撞。

Really important part of doing model assembly 做模型組裝重要的部分

is connecting all those parts together. 將所有這些部分連接在一起

Connectors are really vital to the overall assembly process. 連接器對整個裝配過程至關重要。

The quality of the connector that you create really 您真正創建的連接器的質量

determines the outcome of the quality 確定質量的結果

of the overall assembled model as well. 對整體組裝模型

So for us to get a good high fidelity solution, 所以為我們得到一個良好的高保真度解決方案

you have to have a really good connection generation as well. 你必須有一個非常好的連接生成

&lt;p&gt;翻譯影片hyperworks 14-6中文字幕 &lt;p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/fTgaulekEZ4" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
##內容
The 2017 HyperWorks release has a lot 在2017年HyperWorks發行很多版本

of enhancements to the modeling and assembly capabilities 對軟件的建模和組裝能力的增強

So we put in a new parts browser with a built-in part library 所以我們在一個新的零件瀏覽器與一個內置零件庫

The part library is a great tool for storing and loading work in progress 零件庫是用於存儲和加載正在進行工作的一個很好的工具

So you can store a catalog of all the common parts 因此，您可以存儲所有公共部分的目錄

that a workgroup needs to use,so they can download their models from their PLM system 工作組需要使用，因此他們可以從他們的PLM系統下載他們的模型

and store them locally in a parts library for a work in progress 並將它們本地存儲在正在進行的工作的零件庫中

And it keeps revision control on them, 他保持對它們的修訂控制

so they can back up to the different versions and reload. 所以他們可以備份到不同的版本並重新加載。

And they can also build different configurations now of their models. 他們也可以建立不同的配置到他們現在的的模型。

In the configuration modeler now 現在在配置建模器

they can import parts from part library and then group 他們可以從零件庫導入零件然後分組

them into what we call part sets,which are 他們變成我們所說的部分集

convenient groupings of parts. 即零件方便分組

And then they can drag those parts together into assemblies, 然後他們可以將這些部分一起拖入組件

and configure them for different load 並為不同負載配置它們的

cases or different variations of their models. 情況或他們的模型的不同變化

the other feature of haveing parts in the software 硬件部分的軟件中的另一個特點

is we do part instancing now,too. 我們現在也做實例化

So if you load in a part that has 所以如果你加載在一個部分

multiple instances through the model,we support that. 我們支持多個實例通過模型

We don't have to create multiple copies of it. 我們不必創建它的多個副本

We can actually do the instancing,which is very memory efficient. 我們可以做實際，這是非常有效的記憶。

Also in the model building assembly 也在模型建築組裝

tool set is enhanced ID management as well. 工具集也是增強的ID管理

So not only can we assign IDs based on different rules 因此，我們不僅可以根據不同的規則分配ID

that you define in the software,but you can import ID systems 您可以在軟件中定義，但可以導入ID系統

form spreadsheets,XML files,databases, 形式電子表格，XML文件，數據庫，

and so forth,that are then used when 等等，然後在使用

it does the renumbering or the assembly of the model. 它進行重新編號或模型的組裝

it has to resolve part collisions. 它必須解決部分碰撞。

Really important part of doing model assembly 做模型組裝重要的部分

is connecting all those parts together. 將所有這些部分連接在一起

Connectors are really vital to the overall assembly process. 連接器對整個裝配過程至關重要。

The quality of the connector that you create really 您真正創建的連接器的質量

determines the outcome of the quality 確定質量的結果

of the overall assembled model as well. 對整體組裝模型

So for us to get a good high fidelity solution, 所以為我們得到一個良好的高保真度解決方案

you have to have a really good connection generation as well. 你必須有一個非常好的連接生成
&lt;p&gt;心得&lt;p&gt;
翻了其中一部影片才知道原來翻譯上字幕是一件很辛苦的事  兩分鐘鐘的影片前後用了5.6小時</summary><category term="HW"></category></entry><entry><title>協同產品設計實習 第二周作業</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-di-er-zhou-zuo-ye.html" rel="alternate"></link><published>2017-03-04T12:08:00+08:00</published><updated>2017-03-04T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-03-04:./xie-tong-chan-pin-she-ji-shi-xi-di-er-zhou-zuo-ye.html</id><summary type="html">&lt;p&gt;利用Solvespace繪製四連桿機構&lt;/p&gt;



&lt;p&gt;四連桿&lt;p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/A4StLhnoHjk" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="HW"></category></entry><entry><title>協同產品設計實習 第一周作業</title><link href="./xie-tong-chan-pin-she-ji-shi-xi-di-yi-zhou-zuo-ye.html" rel="alternate"></link><published>2017-02-26T12:08:00+08:00</published><updated>2017-02-26T12:08:00+08:00</updated><author><name>40443111</name></author><id>tag:,2017-02-26:./xie-tong-chan-pin-she-ji-shi-xi-di-yi-zhou-zuo-ye.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h1&gt;利用solvespace及onshape組裝四連桿機構&lt;/h1&gt;
&lt;h2&gt;零件1&lt;/h2&gt;
&lt;p&gt;&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/tygsHRjf6IU" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;零件2&lt;/h2&gt;
&lt;p&gt;&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/3bEXF19xpi4" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;零件3&lt;/h2&gt;
&lt;p&gt;&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/MOzF6LccpD8" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;組裝&lt;/h2&gt;
&lt;p&gt;&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/P0LEwxE7UN8" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;作業心得&lt;/h2&gt;
&lt;p&gt;隔了一個寒假用solvespace變得上手許多&lt;/p&gt;</summary><category term="HW"></category></entry></feed>